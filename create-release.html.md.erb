---
title: Creating a BOSH Release
---

The workflow for creating BOSH releases is iterative, and looks like this:

  <%= image_tag("release-iterate.png") %>

A more detailed description of the workflow reveals how,
as you iterate, BOSH automatically numbers your releases:

1. Develop or modify the application.
1. Create a **dev release**.
  * BOSH bumps the release number by a "dot."
1. Deploy the **dev release** to your test environment.
1. Test the **dev release**.
Is it ready for final release?
    * If the answer is no, begin the cycle again.
    * If the answer is yes, continue.
1. Create a **final release**.
  * BOSH bumps the release number by whole number.
1. When the final release needs to be modified or improved,
begin the cycle again.

As a matter of principle, BOSH releases:

* Package up all dependencies.
* Remain buildable for a long time.
* Avoid adding blobs to a git repository.
* Avoid depending on the internet.

As a matter of good practice, when creating BOSH releases, you should:

* Use underscores in filenames.
* Comment your code to facilitate debugging.
* Assume that stemcells contain no libraries or other software that your release can use.

This tutorial walks you through creating a dev release and then a final release.
_The finished example release is here <download_link>_.
You use the directions to create your own release, comparing your results with the sample code.

The ordering of tasks in this tutorial represents just one way of accomplishing the overall goal.
The BOSH team has found this approach to be efficient,
but these directions are only suggestions unless otherwise noted.

## <a id="what"></a> Decide What to Release ##

A BOSH release contains one or more pieces of software that work together in some way.
For example, you could create a BOSH release of a service that has three pieces: two MySQL nodes and a dashboard app.
People may think of these pieces as areas of functionality, or features, or roles.
In a BOSH release, you make each piece a _job_.

Jobs are among the four fundamental elements in a BOSH release.
Each of the others provides something that another element needs:

* **jobs** describe pieces of the service or application you are releasing.
* **packages** provide source code and dependencies to jobs.
* **source** provides packages the non-binary files they need.
* **blobs** provide packages the binaries they need, other than binaries that are checked into a Git repository.

You make several judgment calls when creating a release:
what to include, how to structure it, and how to split up jobs and packages.
To get started creating a release, decide what jobs your release should include.

For the example release, we have decided to include two jobs: a web UI and a background worker.
The worker periodically sends an HTTP request to the web UI, and the web UI displays the number
of worker requests received.

You also decide what properties to give your jobs.
Job properties are essentially inputs.
We have decided to give our example service one property: the port on which the web UI listens.

## <a id="release-dir"></a> Create the Release Directory ##

All the constituent parts of a release reside in the _release directory_.

`cd` into the workspace where you want the release to be, and create the release directory:

  `bosh init release <release_name> --git`

The `--git` option initializes a git repo in the release directory.
This is recommended but not required.

Our example release is named `ardo-release`.
This name is just an anagram for `dora`, the sample app on which `ardo` is based.
The point is to give the release a name that won't be confused with the names of its parts
(`web_ui` and `bg_worker`).

`cd` into the release directory.
From here on, all the BOSH commands in this tutorial are run from within the release directory.

View the release with `tree`:

<pre class="terminal">
$ tree .
.
├── blobs
├── config
│   └── blobs.yml
├── jobs
├── packages
└── src

5 directories, 1 file
</pre>

Notice that in the release directory, BOSH creates a subdirectory for each
of the fundamental elements: jobs, packages, source (which BOSH calls `src`), and blobs.

### <a id="strategy"></a> A note about work strategy ###

You are about to begin five central parts of the tutorial,
Create Job Skeletons, Make Dependency Graphs, Create Packages, Add Blobs Locally,
and Update Specs to Complete Jobs.
You can go one section at a time, completing one section for all jobs,
doing the same for in the next section, and so on.
Alternatively, you can go one job at a time, completing all four sections for one job,
doing the same for the next job, and so on.

For releases with just a few jobs, going one section at a time is probably easiest.
That is what we'll do in this tutorial.
If you have a larger number of jobs, going one job at a time may be more efficient.
Choose the approach that seems most comfortable and least error-prone.

## <a id="job-skel"></a> Create Job Skeletons ##

When first created, the job is a _skeleton_: an empty structure that fills up
as release creation progresses.

Generate job skeletons by running this command once for each job in your release:

  `bosh generate job <job_name>`

In our example, we run `bosh generate job` twice, once for the `web_ui` job,
and once for the `bg_worker` job.

View the job skeletons with `tree`:

<pre class="terminal">
$ tree .
.
├── blobs
├── config
│   └── blobs.yml
├── jobs
│   ├── bg_worker
│   │   ├── monit
│   │   ├── spec
│   │   └── templates
│   └── web_ui
│       ├── monit
│       ├── spec
│       └── templates
├── packages
└── src

9 directories, 5 files
</pre>

### <a id="control"></a> Create control scripts for the jobs  ###

Every deployed job needs a way to start and stop.
You provide that in a BOSH release by writing a control script for each job.

The control script:

* Includes a start command and a stop command.
* Is an ERb template stored in the `templates` directory for the relevant job.

At compile time, BOSH transforms templates into files, which it then replicates on
VMs where the deployed software runs.
In our example, `ctl.erb` becomes the `bin/ctl` file.

On a deployed release, BOSH accesses the control script and any other templates through
the `monit` file, which references the templates as well as the process ID (pid) file.
_How does monit get created? How to improve my vague wording?_

In production situations, start and stop commands typically turn more things on and off
than the simple commands in our example do.
Control scripts can be the source of unexpected behavior that you discover as you test your dev releases.
When that happens, you refine your scripts and iterate.
For these reasons, writing scripts is typically one of the heavier tasks entailed in creating a release.

For each job, create a control script and save it as `ctl.erb` in the `templates` directory for its job.

_insert ctl.erb as a snippet here? for one job or both?_

If your release needs templates other than the control script, create them now.

### <a id="job-specs"></a> Update job specs  ###

Metadata for each job resides in a `spec` file.

Now that you possess the template names, you should record them in that metadata.

* List each template you have created in the `templates` block of the `spec`
file for its job.
At compile time, BOSH makes templates into files on VMs.
List the template and the path to the corresponding file as a key/value pair.

Update the `spec` files for all the jobs in your release with the template names.

In our example, we edit the `spec` files for the both the `web_ui` and `bg_worker` jobs.
The updated `spec` file for the `bg_worker` job looks like this:

~~~yaml

templates:
  ctl.erb: bin/ctl

~~~

**Note**: The file paths that you provide for templates are relative to
what is in effect a home directory for the job on the VM:

~~~
/var/vcap/jobs/<job_name>/
~~~

For example, the path we provided for the `bg_worker` control script was
`bin/ctl`.
BOSH translates that into the full path `/var/vcap/jobs/bg_worker/bin/ctl`.

### <a id="commit-one"></a> Commit ###

You have now created one or more job skeletons; this is a good time to commit.

Be aware that if you followed the recommended practice of using the `--git` option with
`bosh init release`, the correct `.gitignore` file has been automatically created for you.

## <a id="graph"></a> Make Dependency Graphs ##

There are two kinds of dependencies in a BOSH release:

* The **runtime dependency**, where a job depends on a package at runtime.
For example, the `web_ui` job depends on Ruby.
* The **compile-time dependency**, where a package depends on another package at compile time.
For example, Ruby depends on the YAML library.

Three rules govern these dependencies:

* Jobs never depend on other jobs.
* Jobs can depend on packages.
* Packages can depend on other packages.

Correctly understanding the dependencies between the jobs and packages in your release is essential.
Creating a dependency graph helps you clarify this understanding, and provides a
reference as you add elements to the release.

Identify dependencies by going through your control scripts (and other templates, if any).
Note the package names cited by each script.
In our example, this line in `ctl.erb` cites Ruby:

~~~
exec /var/vcap/packages/ruby_1.9.3/bin/bundle exec
~~~

Add `web_ui`'s dependency on Ruby version 1.9.3 to your dependency graph.
(Later, you add the actual Ruby package to your release.)

The dependency graph for `ardo-release` looks like this:

  <%= image_tag("dep-graph.png") %>


### <a id="..."></a> Update the job spec with dependencies ###

The dependency graph reveals runtime dependencies that
need to be added to the `packages` block of the job spec.

Edit the job spec to include these dependencies.

In our example, the dependency graph shows that `web_ui` job depends on
`ruby_1.9.3`.

~~~yaml
packages:
- web_ui
- ruby_1.9.3
~~~

## <a id="..."></a> Create Package Skeletons ##

Packages give BOSH the information it needs to compile or copy source code
and dependencies and then replicate the resulting executable code
in the proper location on VMs during deployment.

When first created, a package is a _skeleton_: an empty structure to be filled up
as release creation progresses.

Create packages starting from the bottom of your dependency graph.

  `bosh generate package <dependency_or_job_name>`

In our example, we run this command four times.
Starting from the bottom of the dependency graph,
we run it for libyaml_0.1.4, ruby_1.9.3, bg_worker, and web_ui.

View the package skeletons with `tree`:

<pre class="terminal">
$ tree packages
packages
├── bg_worker
│   ├── packaging
│   ├── pre_packaging
│   └── spec
├── libyaml_0.1.4
│   ├── packaging
│   ├── pre_packaging
│   └── spec
├── ruby_1.9.3
│   ├── packaging
│   ├── pre_packaging
│   └── spec
└── web_ui
    ├── packaging
    ├── pre_packaging
    └── spec

4 directories, 12 files
</pre>

**Note**: Use of the `pre_packaging` file is not recommended, and is not discussed in this tutorial.

### <a id="..."></a> Create packaging scripts ###

At compile time, BOSH places executable binaries on the VMs where jobs run
once deployment is complete.
The packaging scripts are your compile-time instructions to BOSH.

* If a package references source code like Ruby or libyaml, you need to instruct BOSH to actually compile
the code.

* If it references an app like `web_ui` or `bg_worker`, you simply instruct BOSH to copy the app.

BOSH relies on you to write packaging scripts that perform the correct operation.

BOSH creates the VMs where deployed jobs run.
BOSH also creates _compilation VMs_ and compiles packages into the install target directory
on them.
BOSH then replicates the install target directory on the regular VMs.
BOSH deletes compilation VMs after compiling all the packages.

The overall interaction between BOSH, the packaging script, and VMs goes like this:

* The packaging script specifies a target directory.
* BOSH creates the target directory on the compilation VM.
* The packaging script provides instructions for compiling the package.
* BOSH compiles binaries as specified in the packaging script.
* BOSH places the compiled binaries in the target directory.
* BOSH replicates the target directory, on a VM where the deployed jobs will run.

Use the `BOSH_INSTALL_TARGET` environment variable in your packaging scripts.
Also, make sure that the `make` command you use in the script is configured to deliver compiled
code to `BOSH_INSTALL_TARGET`.

At compile time, BOSH translates `BOSH_INSTALL_TARGET` to the actual location on deployed VMs
where binaries need to be.
If the instructions you provide in the packaging scripts fail to deliver compiled code to
`BOSH_INSTALL_TARGET`, the job cannot function because the VM has no way to find and run the code.
This failure scenario can happen if, for example, you use a `make` command that by default
delivers compiled code to some standard location.
That is why you need some equivalent of the `configure` command in the example packaging
scripts.

You should also be aware of the role of the `dependencies` block in package `spec` files.
BOSH ensures that the dependencies cited there are available to the deployed binary.
For example, in the `spec` file for the Ruby package, we cite libyaml as a dependency.
That ensures that the Ruby on deployed VMs has access to libyaml.

Like control scripts, packaging scripts require a relatively large proportion of the
labor that goes into creating a release.

Write your packaging scripts now.
To get started, study the examples.

* Use your dependency graph to determine which dependencies belong in each
packaging script.

* Begin each script with a `set -e -x` line.
This aids debugging at compile time by causing the script to exit immediately if an error occurs.

### <a id="..."></a> Update packaging specs ###

Within each package directory is a `spec` file which states:

* The package name.
* The package's dependencies.
* The location where BOSH can find the binaries and other files that the package needs during compilation.

Use your dependency graph to determine which dependencies belong in each spec.
Your personal preferences and style as a developer also play a role here.
Consider our example: the spec for Ruby lists `rubygems` and `bundler` as dependencies along
with Ruby itself.
Some Ruby developers would do it this way; others would not.

Remember not to depend on the presence of libraries or other software on the stemcells that
BOSH uses to create VMs.
This maximizes the portability of your release across different versions of stemcells.

Describe binary locations in the `files` block of the spec according to this convention:

* Find the official site for the binary in question.
For example, Ruby might be at `http://cache.ruby-lang.org/pub/ruby/1.9/ruby-1.9.3-p484.tar.gz`.

* Download the binary from the official location and make sure the file hash matches.

* Record the binary name including version number, with a slash and the binary filename concatenated to it.
It's a good idea to cite the official URL in a comment, in the same line.

BOSH interprets the locations you record in the `files` section as being either in the `src` directory or
in the `blobs` directory. (BOSH looks in `src` first).
When you add the actual blobs to a local blobstore (see the next section), BOSH populates the `blobs` directory with the
correct information.

Observe how these conventions are followed in the examples.

_add examples inline_

## <a id="..."></a> Add Blobs ##

When creating a release, you use Git for your source code.
For example, the `web_ui` and `bg_worker` source is checked into a Git repo.

But your release also uses Ruby and libyaml, which are in the form of binaries
like tar or gem files, also known as blobs.
Since Git is not well-suited to dealing with large binaries,
checking these blobs into Git would be problematic.

You can avoid checking blobs into Git by doing the following:

* For dev releases you direct BOSH to use local copies of blobs.

* When creating a final release, you upload blobs to a blobstore,
then direct BOSH to obtain the blobs from there.

### <a id="..."></a> Configure a blobstore  ###

Every release has one `config` directory, where you record the information BOSH needs to
work with blobstores.

In the `config` directory:

* The `final.yml` file names the blobstore and declares its type, which is either `local`
or one of several other types that specify blobstore providers.

* The `private.yml` file specifies the path of the blobstore, along with a secret.

`private.yml` contains keys for accessing the blobstore.
For that reason, `private.yml` is automatically gitignored (assuming you used the `--git`
option when running `git init release` at the beginning of this tutorial).
By not checking `private.yml` into Git, BOSH keeps the keys private.

**Note**: A peculiarity of the `local` type blobstore is that the `blobstore_secret`
line is required, although it is deprecated and its content does not matter.
There is no `blobstore_secret` line for other types of blobstores.

The `config` directory also contains two files whose content is automatically
generated: the `blobs.yml` file and the `dev.yml` file.

Adapt the example `final.yml` and `private.yml` files to fit the specifics of your release.

_insert examples_

### <a id="..."></a> Inform BOSH where blobs are ###

Each package has a `spec` file, which has a `files` block.
For packages whose content you downloaded from the internet,
the `files` block lists the binaries you downloaded, along with
the URLs from which you downloaded them.
(This assumes that you followed the directions in the [Update package specs] section.)

Those files are blobs, and now you need the paths to the downloaded blobs on
your local system.

In our example, the `spec` file for the `libyaml_0.1.4` package includes the line:

~~~yaml
files:
- libyaml_0.1.4/yaml-0.1.4.tar.gz # From http://pyyaml.org/download/libyaml/yaml-0.1.4.tar.gz
~~~

If you downloaded the blob, its local path might be:

`~/Downloads/yaml-0.1.4.tar.gz`

Go through all your packages and make a list of local paths to the blobs you downloaded.
Now you are ready to inform BOSH about these blobs.

For each blob, run:

`bosh add blob <path_to_blob_on_local_system> <package_name>`

### <a id="..."></a> Do not upload blobs for a dev release ###

The nature of blobstores (other than local ones) is that once you have uploaded blobs,
those blobs may become essential to some other developer.
For this reason, uploading a blob and then removing it is considered poor practice.

When creating dev releases, you should run `bosh add blob` to inform
BOSH of local paths to blobs, but refrain from running `bosh upload blobs`.
That command is discussed in connection with final releases.

## <a id="..."></a> Update Specs to Complete Jobs ##

_what have we not done yet?_

## <a id="..."></a> Create Job Properties  ##

* Properties are inputs ...
* Coordinating with the `properties` block in the manifest...

## <a id="..."></a> Do a Dev Release  ##

We have:

* blobs
* source
* script to build from source
* control script


### <a id="..."></a> Release  ###

Can't create release before uploading blobs unless we use the `--force`
option, which tells BOSH to use the blobs in the local blobstore.
This is permissible when creating and testing dev releases but not
final releases.

`bosh create release --force`

BOSH asks for release name.
For a dev release, this can be anything.

### <a id="..."></a> Deploy the Dev Release  ###

Target a director.

See what releases are available:

  `bosh releases`

If BOSH is already pointing to a release, edit the BOSH deployment manifest.
Otherwise, [create a manifest] (./create-manifest.html).

Upload the new dev release.
If in the release directory, no path needed:

   `bosh upload release`

Deploy:

   `bosh deploy`

### <a id="..."></a> Test the Dev Release  ###

What tests to run depends on the software you are releasing.

* Debug primer: log in on VM, etc.

If your release fails any of these tests:

* Fix
* Do a new dev release and then bosh deploy to see that new release succeeds deploying.
* You can use `bosh deploy --recreate` to deploy all VMs from scratch.

## <a id="..."></a> Do a Final Release  ##

Only proceed to this step if your latest dev release passes all tests.

### <a id="..."></a> Upload blobs ###

You are ready to do a final release except for one thing:
your latest dev release depends on locally-stored blobs.

Before you go further, run `bosh blobs`.
Proofread the list of blobs to make sure
it includes nothing but the blobs you need for the final release.

If some file that you need to keep private is mistakenly
uploaded to a blobstore, there is no satisfactory way to
undo the error.

Now you can upload your blobs to a blobstore:

`bosh upload blobs`

### <a id="..."></a> Commit ###

You have run the `bosh upload blobs` command so the `blobs` file now contains names and keys.

This is a good time to commit.

### <a id="..."></a> Release ###

Run:

`bosh release --final`

BOSH prompts you for a release name, and assigns a whole-number version to the release.

This is a good time to `git push` so that other team members have access to final release you just created.


### <a id="..."></a> Commit ###

One more commit before you deploy.

### <a id="..."></a> Deploy the Final Release  ###

Run:

`bosh deploy`

