---
title: Creating a BOSH Release
---

Suppose you want to create a BOSH release of an application that you have developed.

BOSH releases are created using an iterative workflow:

1. Develop the application.
1. Create a **dev release**.
  * BOSH bumps the release number by a "dot".
1. Deploy the **dev release** to your test environment.
1. Test the **dev release**.
Is it ready for final release?
    * If the answer is no, begin the cycle again.
    * If the answer is yes, continue.
1. Create a **final release**
  * BOSH bumps the release number by whole number.

The BOSH release workflow embodies some principles intended to make BOSH releases
optimally useful.
Among these principles are the following:

* BOSH releases do not necessarily depend on the internet.
* BOSH release don't add blobs to GitHub.
* Using underscores in filenames is the BOSH way.
* Commenting your code to facilitate debugging is the BOSH way.

## <a id="..."></a> Decide What to Release ##

Some releases contain a single app.
Others are collections of related pieces of software.
For example, such a collection might include a few MySQL nodes along with a dashboard app.

In a BOSH release, each of these pieces of software is a _job_.
You also need to know the conception of _packages_, _src_, and _blobs_ that apply in
the world of BOSH releases.

* **jobs** describe pieces of a service
* **packages** provide source code and dependencies to jobs
* **src** provide non-binary files to packages
* **blobs** provides binaries not checked into git

Where to draw the line between what should and should not be included in a release
is a judgment call when you are dealing with more complex examples of distributed software.



### <a id="..."></a> About this tutorial ###

This tutorial walks you through creating a dev release and then a final release
that contains a single job, namely a Sinatra app called `ardo`.

## <a id="..."></a> Create the Release Directory ##

Make the release directory:

  `bosh init release --git`

* `cd` into it.
* All commands in the example are run from here.

## <a id="..."></a> Create the Job Skeleton ##

This command generates a job _skeleton_, meaning ...

  `bosh generate job ardo-web`

### <a id="..."></a> Create a control script for the job  ###

* In the spec for the job, create a template for the control script.
* Templates are `erb` files, so this one is `ctl.erb.`
* The spec shows the file that template will become in the actual app at compile time:
  `ctl.erb: bin/ctl`
* Create start and stop scripts and save them as `ctl.erb.`
* Some real development work here, maybe to iterate on later.
* `set -e -x`

### <a id="..."></a>   ###

* In the packages block of the spec, add a line describing a package for the job.
* The actual package does not exist yet.

### <a id="..."></a> Commit ###

## <a id="..."></a> Create Dependency Package Skeletons ##

A BOSH release contains one package for each of its jobs,
and additional packages, one for each dependencies.
To see clearly what packages you need to create,
start by making a dependency graph.

Then take a bottom-up approach, creating package skeletons
for dependencies, while leaving the job package for later.

### <a id="..."></a> Make a dependency graph ###

Two kinds:

* job dependency
* package dependency

Rules:

* jobs never depend on other jobs
* jobs can depend on packages
* packages can depend on other packages

### <a id="..."></a> Add package skeletons ###

First create packages for job dependencies.
The job in our example release is a Sinatra app,
whose only dependency is on Ruby.

  `bosh generate package ruby_1.9.3`

* correct name in the spec (now is ruby_1.9.3 not plain ruby)

Next, create packages for package dependencies.
The only package dependency in our example is that the Ruby
package depends on the YAML library.

  `bosh generate package libyaml_0.1.4`

You now have package skeletons for all the dependencies in your release.
Later on, you will flesh out the skeletons to make them usable packages.

## <a id="..."></a> Add Blobs Locally ##

When creating a release, you use git for your source code.
Git is not well-suited to dealing with large binaries, however.
For this reason, you add blobs to a local blobstore while creating
dev releases.

Before you create a final release, you typically upload the blobs to a public blobstore.

### <a id="..."></a> Decide what blobs to add ###

* running `bosh add blob` now would fail with an error

### <a id="..."></a> Create a local blobstore  ###

* in `config` folder: `final.yml` and `private.yml`

### <a id="..."></a> Add blobs to blobstore ###

* in release directory:
  `bosh add blob <path> <package_name_as_prefix><filename>`

## <a id="..."></a> Update Specs ##

### <a id="..."></a> Add blob to dependency spec ###

* libyaml spec needs to know about libyml blob
* BOSH looks in two locations: `src` and `blobs`

### <a id="..."></a> Update package spec with dependency information  ###

* Add ruby's dependence on libyaml to Dependencies section of ruby spec
* satisfies a line in the `packaging` script

### <a id="..."></a> Update package spec with blobs information ###

* ruby, rubygems, bundler
* with `ruby_1.9.3` prefix â€” all part of that package
* `bosh blobs` to see that they are there and copy filenames
* paste filenames into the `ruby_1.9.3` spec

## <a id="..."></a> Create the Job Package  ##

* Up to now all we have is a mention of the package in the job spec.
* Now we create the job package itself:

  `bosh generate package ardo-web`

* The package contains a `spec` and a `packaging` script, both empty when
the package is newly created.
* Next, put useful information into `spec` and `packaging`.

### <a id="..."></a> Update the job package spec with dependency information ###

* In `dependencies` block, name the dependencies.
* In `files` block, use a glob to specify the pattern that matches the files.
** By convention, the `src` directory should contain a sub-directory named for the job.
** Use a glob that does a deep traverse of the `src/ardo-web` directory.

### <a id="..."></a> Write the packaging script for the job ###

* This transforms the package at compile time.
* Refer to section explaining variables BOSH gives you.
** Described in BOSH code.
** Any file you put in there ends up on the VM ("install target") ...


## <a id="..."></a> Create Properties  ##

* Properties are inputs ...
* Coordinating with the `properties` block in the manifest...

## <a id="..."></a> Do a Dev Release  ##

We have:

* blobs
* source
* script to build from source
* control script

Can't create release before uploading blobs unless we use the `--force`
option, which tells BOSH to use the blobs in the local blobstore.
This is permissible when creating and testing dev releases but not
final releases.

`bosh create release --force`

BOSH asks for release name.
For a dev release, this can be anything.

## <a id="..."></a> Deploy the Dev Release  ##

Target a director.

See what releases are available:

  `bosh releases`

If BOSH is already pointing to a release, edit the BOSH deployment manifest.
Otherwise, [create a manifest] (./create-manifest.html).

Upload the new dev release.
If in the release directory, no path needed:

   `bosh upload release`

## <a id="..."></a> Test the Dev Release  ##

* Debug primer: log in on VM, etc.
* If your release fails any of these tests, fix and do a new dev release.

## <a id="..."></a> Do a Final Release  ##

Only proceed to this step if your latest dev release passes all tests.

### <a id="..."></a> Upload blobs ###

  `bosh upload blobs`

### <a id="..."></a> Release ###

  `bosh release --final`


## <a id="..."></a> Test the Final Release  ##







