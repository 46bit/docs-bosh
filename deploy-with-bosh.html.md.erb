---
title: Deploying Distributed Software with BOSH
---

There are many ways to use BOSH to deploy distributed software.

For example, you could:

* Use multi-VM BOSH to deploy a BOSH release of a key-value store.
* Use multi-VM BOSH to deploy Cloud Foundry.
* Use MicroBOSH to deploy a distributed messaging service.

In this tutorial, we focus on yet another example: using MicroBOSH to deploy multi-VM BOSH.
This use case is appropriate if, for example, you want to use multi-VM BOSH as
your primary toolset for deploying other distributed software and for managing the lifecycle of that software.

When you work through this tutorial, you experience what the BOSH development
team thinks of as a canonical example of using BOSH.
Even if you plan to use BOSH in a different way, this story should provide a useful sense of
how things are supposed to work.

## <a id="prep"></a> Preparing to Deploy ##

Preparation consists of thinking through how to orchestrate the environment you want to deploy,
and how to configure the network and instrument VMs.
You need to set up your IaaS instance and collect the networking information that goes in the manifest.
Then you create the manifest and obtain a release and a stemcell.

### <a id=""></a> Plan how you want to orchestrate your environment ###

For the sake of this example, let's assume that you have decided to deploy BOSH to an environment with two VMs.
One reason you might do this is to implement a security architecture where the data-storing parts of BOSH
(Blobstore, Redis, and Postgres) reside on one VM, while the "thinking" parts of BOSH
(Director, Health Monitor, NATS, and PowerDNS) reside on the other.
This would allow you to restrict access to data, while allowing deployment operators freer access to
the BOSH Director.

### <a id=""></a> Set up the IaaS ###

You collect the information about your vSphere and vCenter that you need to configure the environment.

This includes:

* The names for your datacenter, datastore, cluster, resource pool, and network.
* The IP addresses for your vCenter and network gateway.
* The IP addresses for the VMs to be deployed, called static IP addresses
* The range of IP addresses of your network.
* The range of IP addresses that you want to reserve.
These, and the static IPs, are off-limits to BOSH when BOSH needs to dynamically use an IP address for tasks like compilation.
You always reserve the IP of the MicroBOSH that deploys BOSH.

### <a id=""></a> Create the manifest ###

Create the manifest to reflect the desired orchestration of the environment along with the network configuration information
for your IaaS.
Refer to the [example manifest](#example-manifest) at the end of this topic.

### <a id=""></a> Download stemcell and release from public site ###

You download the latest release of BOSH, and a stemcell suitable for your preferred combination of IaaS and VM type.
In this example, these are:

* The **bosh-2131** release
* The **vsphere esxi centos** stemcell

**Note**: This is only an example, so you can expect release numbers to be out of date by the time you read this.

### <a id=""></a> Target and log into MicroBOSH ###

Ensure that the BOSH CLI runs on the MicroBOSH you want to use to deploy software.
(In some environments there might be more than one BOSH or MicroBOSH.)
You do this by passing the IP address of the MicroBOSH to the `bosh target` command.

<pre class="terminal">
$ bosh target 172.16.99.11
Target set to `embarcadero-microbosh'
</pre>

Then log in on the MicroBOSH.
Run the `bosh vms` command which shows VMs that the (Micro)BOSH has deployed.
For now, `bosh vms` shows no VMs deployed.

<pre class="terminal">
$ bosh login admin ********
Logged in as `admin'

$ bosh vms
No deployments
</pre>

## <a id="deploying"></a> Deploying ##

Enact the [familiar pattern](./workflow.html#deploying) _upload stemcell, upload release, set deployment, deploy_.

### <a id="stemcell"></a> Upload the Stemcell ###

<pre class="terminal">
$ bosh upload stemcell ~/Downloads/bosh-stemcell-2089-vsphere-esxi-centos.tgz

Verifying stemcell...
File exists and readable                                     OK
Verifying tarball...

...

Uploading stemcell...

bosh-stemcell: 100% |oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo| 558.9MB  39.4MB/s Time: 00:00:14
</pre>

Run the `bosh stemcells` command to verify that the stemcell you had before is no longer present on your local system,
because it has been uploaded to MicroBOSH:

<pre class="terminal">
$ bosh stemcells
No stemcells
</pre>

### <a id="release"></a> Upload the Release ###

<pre class="terminal">
$ bosh upload release ~/Downloads/bosh-2131.tgz

Verifying release...
File exists and readable                                     OK
Extract tarball                                              OK
Manifest exists                                              OK
Release name/version                                         OK

....

Release has been created
  bosh/42 (00:00:00)
Done                    1/1 00:00:00

Task 18 done

Started		2014-03-07 06:16:09 UTC
Finished	2014-03-07 06:16:10 UTC
Duration	00:00:01

Release uploaded
</pre>

### <a id="manifest"></a> Set Deployment with a Manifest ###

<pre class="terminal">
$ bosh deployment ~/workspace/deployments-vcenter/embarcadero/bosh2/manifest.yml
Deployment set to `/Users/pivotal/workspace/deployments-vcenter/embarcadero/bosh2/manifest.yml'
</pre>

### <a id="deploy"></a> Deploy ###

<pre class="terminal">
$ bosh deploy
Getting deployment properties from director...
Compiling deployment manifest...
Please review all changes carefully
Deploying `manifest.yml' to `embarcadero-microbosh' (type 'yes' to continue): yes

...

Started		2014-03-07 06:38:12 UTC
Finished	2014-03-07 06:39:52 UTC
Duration	00:01:40

Deployed `manifest.yml' to `embarcadero-microbosh'
</pre>

## <a id="verify"></a> Verifying the Deployment ##

While the output you have seen indicates that deployment was successful,
you can run some basic checks on your new multi-VM BOSH.

Set your local BOSH CLI to communicate with the new BOSH Director.

<pre class="terminal">
$ bosh target 172.16.69.232
Target set to `bosh2'
Your username: admin
Enter password: *****
Logged in as `admin'
</pre>

Run `bosh status` to verify that everything looks right.

<pre class="terminal">
$ bosh status
Config
             /Users/pivotal/.bosh_config

Director
  Name       bosh2
  URL        https://172.16.69.232:25555
  Version    1.2131.0 (release:bee75ed2 bosh:bee75ed2)
  User       admin
  UUID       d2ad4585-ea92-4652-8c07-1ba6625b9220
  CPI        vsphere
  dns        enabled (domain_name: bosh)
  compiled_package_cache disabled
  snapshots  enabled

Deployment
  not set
</pre>


## <a id="example-manifest"></a> Example Manifest ##

~~~yaml
---
name: bosh2
director_uuid: 6bcdfa35-5d51-4d39-8360-6e2b97cad2bc
release:
  name: bosh
  version: 42

networks:
- name: default
  type: manual
  subnets:
  - range: 172.16.68.0/23
    gateway: 172.16.68.1
    static:
    - 172.16.69.232
    - 172.16.69.233
    reserved:
    # .1 is special
    - 172.16.68.2 - 172.16.69.230
    - 172.16.69.240 - 172.16.69.254
    # .255 is special
    dns:
    - 10.80.130.1
    cloud_properties:
      name: 'CF_2'

resource_pools:
- name: default
  stemcell:
    name: bosh-vsphere-esxi-centos
    version: 2131
  network: default
  size: 2
  cloud_properties:
    ram: 512
    disk: 2_000
    cpu: 2

compilation:
  reuse_compilation_vms: true
  workers: 1
  network: default
  cloud_properties:
    ram: 512
    disk: 6_000
    cpu: 2

update:
  canaries: 1
  canary_watch_time: 30000 - 90000
  update_watch_time: 30000 - 90000
  max_in_flight: 1
  max_errors: 1

jobs:
- name: bosh_data
  template:
  - blobstore
  - postgres
  - redis
  instances: 1
  resource_pool: default
  persistent_disk: 8_000
  networks:
  - name: default
    static_ips:
    - 172.16.69.233

- name: bosh_api
  template:
  - nats
  - director
  - health_monitor
  - powerdns
  instances: 1
  resource_pool: default
  networks:
  - name: default
    static_ips:
    - 172.16.69.232

properties:
  ntp: ["10.80.130.1"]

  nats:
    user: nats
    password: nats-password
    address: 172.16.69.232
    port: 4222

  blobstore:
    address: 172.16.69.233
    port: 25251
    backend_port: 25552
    agent:
      user: agent
      password: agent-password
    director:
      user: director
      password: director-password

  postgres: &bosh_db
    user: bosh
    password: bosh-password
    host: 172.16.69.233
    port: 5432
    database: bosh

  redis:
    password: redis-password
    address: 172.16.69.233
    port: 25255

  director:
    name: bosh2
    address: 172.16.69.232
    port: 25555
    encryption: false
    enable_snapshots: true
    max_tasks: 100
    db: *bosh_db

  hm:
    http:
      port: 25923
      user: admin
      password: admin-password
    director_account:
      user: admin
      password: admin-password
    intervals:
      poll_director: 60
      poll_grace_period: 30
      log_stats: 300
      analyze_agents: 60
      agent_timeout: 180
      rogue_agent_alert: 180
    loglevel: info
    email_notifications: false
    tsdb_enabled: false
    cloud_watch_enabled: false
    resurrector_enabled: true

  dns:
    address: 172.16.69.232
    recursor: 10.80.130.1
    db: *bosh_db

  vcenter:
    address: 172.16.69.3
    user: root
    password: vmware
    datacenters:
      - name: TEST_DATACENTER
        vm_folder:       SYSTEM_MICRO_VSPHERE_VMs
        template_folder: SYSTEM_MICRO_VSPHERE_Templates
        disk_path:       SYSTEM_MICRO_VSPHERE_Disks
        datastore_pattern:            datastore1
        persistent_datastore_pattern: datastore1
        allow_mixed_datastores: true
        clusters:
          - TEST_CLUSTER:
              resource_pool: TEST_RP
~~~



