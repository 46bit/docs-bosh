---
title: Create a Manifest
---

When you discover a distributed software product that you want to deploy to the cloud using BOSH,
you download a BOSH release of the product and locate a stemcell appropriate for your preferred combination of VM and IaaS.

Next, you need to decide how to orchestrate and configure the deployment,
and to express your decisions in a form that BOSH can consume: namely, a deployment manifest.
This topic explains how manifests work and how to create them.

## <a id="orchestrate"></a> Specifying Orchestration ##

Suppose the product you want to deploy can do five things: call these capabilities Feature A through Feature D.
You want your deployment to take advantage of all five features, but you don't want any one VM to be responsible for more than two features.
For the sake of capacity and resilience, you want every feature to run on more than one VM.

To achieve this, you define VM types, where each type supports different features.
Then you decide how many instances of each VM type to create. Now how have orchestrated your deployment.

In the manifest you specify orchestration along with everything else about your deployment,
including the stemcell, release, and network configuration to use.

## <a id="release"></a> Translating from Release to Manifest ##

When you orchestrate, you allocate features to VM types and then specify a number of instances for each VM type.
You need to see what a product calls its features in the BOSH release in order to specify orchestration in the manifest.

The terms "job" and "template" have one meaning in the release and another in the manifest.

* A BOSH release uses the term "job" to describe a _feature_.
* Meanwhile, a BOSH manifest uses the term "job" to describe a _VM type_,
and the term "template" to describe a feature.
* When you allocate a feature to a VM type, the feature described as a "job" in the release becomes a "template" in the `jobs` block in the manifest.
You name your VM types as "jobs" and specify a number of instances for each.

In the illustration below, five features found in a release are allocated to VM types in a manifest.

 <%= image_tag("orchestrate_sm_3.png") %>

The manifest fragment below shows two VM types, each of which supports two features.

<pre class="terminal">
jobs:
- name: vm-type-x
  templates:
  - name: feature-a
    release: foo_beta
  - name: feature-d
    release: foo_beta
  instances: 2
  resource_pool: default
  persistent_disk: 10240
  networks:
  - name: default
    default: [dns, gateway]
- name: vm-type-y
  templates:
  - name: feature-b
    release: foo_beta
  - name: feature-c
    release: foo_beta
  instances: 4
  resource_pool: default
  persistent_disk: 20480
  networks:
  - name: default
    default: [dns, gateway]
</pre>


## <a id="anatomy"></a> Anatomy of a Manifest ##

Some of the information in any given BOSH manifest is IaaS-specific.
The vast majority of manifest content, though, is independent of the cloud infrastructure where you want to deploy.
This makes it possible to re-use manifests, making minimal changes, even when moving a deployment from one IaaS to another.

A BOSH deployment manifest begins by identifying the deployment as follows:

1. The **name** you give the deployment.
1. The `director_uuid` _insert text here_ to ensure that you deploy with the correct BOSH.
1. The **release name** you choose.
1. The **release version** which _insert description here_.

For example:

<pre class="terminal">
---
name: dummy
director_uuid: 080a8261-8bf8-4996-a754-2545a99c0b2c

releases:
- name: dummy_a
  version: latest
</pre>

After that, the manifest has six required _blocks_:

1. compilation
1. update
1. resource_pools
1. networks
1. jobs
1. properties

Manifests are written in YAML, which means that each block is translated into a hash.
You can put the blocks in any order.

### <a id='compilation'></a> The compilation block ###

BOSH compiles all the software packages within the release at deploy time.
The `compilation` block specifies which VMs should perform the compilation.

### <a id='update'></a> The update block ###

The `update` block:

* Uses the `max_in_flight` variable to limit the number of VMs that can be updated simultaneously.
* Specifies the number and desired behavior of "canaries."

Before BOSH updates all the instances of a given VM type, it updates one or more "canaries,"
and monitors to update to determine whether it can run successfully on that VM type.

A "canary" is just an instance of the VM type to be updated.

If the "canary" update fails, or even appears to succeed too quickly, BOSH does not proceed to update the rest of the instances.
_maybe insert more explanation here_

### <a id='resource_pools'></a> The resource_pools block ###

Resource pools are collections of VMs which are on the same network, are the same kind of VM from the IaaS's perspective, and are built from the same stemcell.
The `resource_pools` block specifies all of these.

### <a id='networks'></a> The networks block ###

The `networks` block is where you specify network configuration information for the deployment.
Networks are named, enabling you to specify multiple networks.

### <a id='jobs'></a> The jobs block ###

The `jobs` block is where you name VM types and specify:

* The product features each type supports, in the form of templates.
* Some configuration information that applies to the VM type as opposed to the feature.

Features (templates) typically require configuration.
You specify this information in the `properties` block.

### <a id='properties'></a> The properties block ###

The `properties` block consists of headings which are the names of features (templates) from the `jobs` block.
Each heading is followed by one or more lines of configuration information.

## <a id="example"></a> A Basic Example Manifest ##

_insert example and reference other examples?_

## <a id="creating"></a> How to Create a Manifest ##

You can modify example manifests to suit your purposes.

Another approach is to use a tool like spiff to create a manifest.
_say more_



